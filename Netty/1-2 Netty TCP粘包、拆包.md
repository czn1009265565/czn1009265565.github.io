## 现象
假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为四种

1. 正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包
2. 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送
3. 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送
4. 拆包和粘包：packet1过大，进行了拆包处理，而拆出去的一部分又与packet2进行粘包处理


## 解决方案
- 发送端将每个包都封装成固定的长度，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度
- 发送端在每个包的末尾使用固定的分隔符，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议
- 将消息分为头部和消息体，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；
- 通过自定义协议进行粘包和拆包的处理

## Netty 解决方案

Netty对解决粘包和拆包的方案做了抽象，提供了一些解码器（Decoder）来解决粘包和拆包的问题。如：

- LineBasedFrameDecoder：以行为单位进行数据包的解码
- DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码
- FixedLengthFrameDecoder：以固定长度进行数据包的解码
- LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议(最常用)