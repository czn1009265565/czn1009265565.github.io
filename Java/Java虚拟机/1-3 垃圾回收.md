# 垃圾回收

## 对象死亡判定

### 引用计数法
实现原理较为简单，新增一个引用计数器，对象引用则加一，对象失效则减一，计数器为0的对象就是不再使用的。存在的问题:无法解决循环引用。

### 可达性分析算法
GC Roots对象作为起始点，向下搜索，走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连，则证明此对象是不可用的。  

#### GC Roots
1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
2. 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

## 垃圾收集算法

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

### 标记清除算法
标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。

在标记阶段首先通过根节点(GC Roots)，标记所有从根节点开始未被引用的垃圾对象。然后，在清除阶段，清除所有被标记的对象。

**缺点:**  
1. 标记和清除都需要扫描整个空间
2. 容易产生内存碎片

### 复制算法
将内存按容量划分为大小相等的两块，每次只使用一块，当一块用完时将还存活的对象复制到另一块上面，
然后一次性清除已使用过的内存空间。适用于新生代

### 标记整理算法
先标记后整理，所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代

### 分代收集算法
只是根据不同代的特点采用不同的收集算法，新生代采用复制算法，老年代采用标记整理算法。

#### 回收类型

- 新生代回收(Minor GC | Young GC)，只对新生代进行垃圾收集
- 老年代回收(Major GC)，只对老年代进行垃圾收集，一般执行Major GC的同时往往会伴随Minor GC，因此可以认为Major GC ≈ Full GC
- 整堆回收(Full GC)，收集整个 Java 堆和方法区