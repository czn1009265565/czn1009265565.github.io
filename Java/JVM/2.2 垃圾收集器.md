## 垃圾收集器

| 垃圾收集器名称           | 串行or并行or并发 | 垃圾回收算法 | 作用域     | 追求目标              | 特点                                   |
|-------------------|------------|--------|---------|-------------------|--------------------------------------|
| Serial            | 串行         | 复制算法   | 新生代     | 降低GC停顿时间          | 单线程，主要运行在client模式，但在并发能力较弱的机器上有更好的表现 |
| ParNew            | 并行         | 复制算法   | 新生代     | 降低GC停顿时间          | 只是简单的Serial多线程化，回收线程和算法都与Serial一致    |
| Parallel Scavenge | 并行         | 复制算法   | 新生代     | 高吞吐量              | 自适应调节新生代、老年代比例，其余和 ParNew 类似         |
| Serial Old        | 串行         | 标记整理   | 老年代     | 降低GC停顿时间          | Serial的老年代版本，主要运行在client模式           |
| Parallel Old      | 并行         | 标记整理   | 老年代     | 高吞吐量              | Parallel Scavenge的老年代版本              |
| CMS               | 并发         | 标记清除   | 老年代     | 降低GC停顿时间          | 在CMS回收过程中，应用程序依旧可以工作，但会占用部分CPU，降低吞吐量 |
| G1                | 并发         | 分区算法   | 新生代+老年代 | 在延迟可控的时间内获得更高的吞吐量 | 高并发、低停顿，但内存占用、负载消耗都比较高               |
### 吞吐量概念

吞吐量 = 应用时间/(GC时间+应用时间)

### Client与Server模式 

JVM的Client模式:
   1. 优化快速启动时间和应用程序的响应性能；
   2. 编译器使用C1编译器，快速编译，但代码质量不如Server模式；
   3. 适用于单线程程序
   4. 可能会牺牲执行速度来实现快速启动时间。

JVM的Server模式:
   1. 优化长时间运行的性能，对响应时间要求不高的应用程序使用；
   2. 编译器使用C2编译器，优化编译，生成高质量的本地代码，执行效率高；
   3. 适用于多线程、多用户并发的应用程序；
   4. 对于一些需要长时间运行的服务，如Web应用、数据库等，使用Server模式可以大大提高性能。

总体来说，Client模式更适用于桌面应用程序，Server模式更适用于服务器应用程序。


### 垃圾收集器使用命令

| 参数                      | 描述                                                                                             |
|-------------------------|------------------------------------------------------------------------------------------------|
| -XX:+UseSerialGC        | 虚拟机运行在Client模式下的默认值，使用Serial + Serial Old 进行垃圾回收                                               |
| -XX:+UseParNewGC        | 使用ParNew + Serial Old 进行垃圾回收， JDK1.9后不再支持                                                      |
| -XX:+UseConcMarkSweepGC | 使用ParNew + CMS + Serial Old(CMS失败的后备) 收集器组合进行垃圾回收                                              |
| -XX:+UseParallelGC      | 在JDK 7U4之前使用Parallel Scavenge + Serial Old，在JDK 7U4之后使用Parallel Scavenge + Parallel Old 进行垃圾回收 |
| -XX:+UseParallelOldGC   | 使用Parallel Scavenge + Parallel Old 进行垃圾回收                                                      |
| -XX:+UseG1GC            | JDK1.9之后在server模式下的默认值，开启后使用G1收集器                                                              |

JDK 默认垃圾收集器（使用 `java -XX:+PrintCommandLineFlags -version` 命令查看）：

- JDK 8: Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK20: G1


### 垃圾收集器详解

#### Serial
它是最基础,历史上最悠久的收集器, 是一个新生代的单线程收集器，标记和清理都是单线程，优点是简单高效；在工作的时候必须"stop the world".

#### ParNew
新生代收并行集器，实际上是Serial收集器的多线程版本，只是简单的将Serial并行化, 在多核CPU环境下有着比Serial更好的表现；对于其他回收策略,收集算法等等均与Serial一致

#### Parallel Scavenge
也是一款新生代并行收集器，同样是基于标记整理算法, 表面上和ParNew非常相似,但最大的不同点就是,Parallel Scavenge的目标在于提升吞吐量.它也是jdk8在server模式下的新生代默认收集器.

由于与吞吐量密切相关,Parallel Scavenge有一个参数还是比较重要的,-XX:+UseAdaptiveSizePolicy.这是一个开关,当这个参数被激活后,就不需要人工指定新生代,老年代大小等细节参数了,虚拟机会根据当前系统的运行情况动态调整这些参数以获得最合适的停顿时间或最大的吞吐量.这种调节方式被称为垃圾收集器的自适应调节策略.

#### Serial Old
Serial Old收集器是Serial的老年代版本,采用标记-整理算法,是一个单线程收集器,这个收集器的主要意义也是提供客户端模式下的HotSpot虚拟机使用.

#### Parallel Old
Parallel Scavenge收集器的老年代版本；采用标记-整理算法,支持多线程并发收集.同样追求高吞吐量.

#### CMS
老年代并行收集器，采用标记清除法, 追求最短回收停顿时间,具有高并发、低停顿的特点.
缺点:  
1. CPU资源占用，CMS默认的回收线程数是(CPU个数+3)/4，即GC线程与用户线程抢占CPU
2. 浮动垃圾，并发清理阶段用户线程还在运行，这段时间就可能产生新的垃圾，新的垃圾在此次GC无法清除，只能等到下次清理
3. CMS使用标记清除算法，收集结束之后会产生大量内存碎片

从 JDK9 开始，CMS 收集器已被弃用

#### G1
G1收集器是垃圾收集器技术发展史上里程碑式的成果.目前已经是jdk9及以上版本的server模式下的默认垃圾收集器了.  
G1相比CMS有很多的优点,比如说不会产生空间碎片、回收之后能够提供规整的可用内存、更不容易产生Full GC等等.但G1对对于CMS的碾压并不是全方位的,例如:G1为了垃圾回收而使用的内存和运行时的额外负载都比CMS要高.

### 适用场景及推荐
以上七款经典的垃圾回收器,并没有绝对的好坏之分,更不存在"万能"的垃圾收集器.所以我们只能根据具体应用,具体环境去选择最适合的一个垃圾收集器.

首先要明确一个观点,如果默认的收集器没有达到预期的性能，那么首先尝试调整堆和代的大小以满足预期的目标。如果性能仍然不够，再尝试不同的收集器:使用并发收集器来减少暂停时间，并使用并行收集器来提高多处理器硬件上的总体吞吐量。

1. 如果应用程序就是一个小内存(最多大约100 MB)，建议使用选项-XX:+UseSerialGC选择串行收集器。
2. 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，那么使用选项-XX:+UseSerialGC选择串行收集器。
3. 如果应用程序性能、吞吐量是第一优先级，并且没有暂停时间要求，一秒钟或更长时间的暂停都是可以接受的，那么建议使用-XX:+UseParallelGC或-XX:+UseParallelOldGC 选择并行收集器。纯后台程序无交互,并且是多处理器的,推荐考虑-XX:+UseParallelOldGC
4. 如果响应时间比总体吞吐量更重要，比如说与用户进行交互的,垃圾收集暂停必须很短，那么可以CMS或G1作为垃圾收集器,-XX:+UseG1GC或-XX:+UseConcMarkSweepGC，
目前在小内存的应用上,CMS的表现大概率仍会优于G1,而在大内存应用上,G1则大多能发挥其优势,这个优劣势的堆容量平衡点在6-8G之间.
