## Java内存区域
根据是否线程共享可以划分为两部分。

**线程共享：**  
1. 堆
2. 方法区(JDK1.8之前叫永久代，JDK1.8之后叫元空间)

**线程私有：**
1. 程序计数器
2. 虚拟机栈
3. 本地方法栈

方法区是Java虚拟机中的一个规范，永久代是JDK1.8之前对方法区的实现，元空间是JDK1.8开始的一种新的实现，
元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存


### 程序计数器
1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制。
2. 在多线程情况下，程序计数器记录的是当前线程执行的位置，当线程切换时，找到当前执行的位置

### 虚拟机栈
Java虚拟机栈是每个线程私有的，它的声明周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。
线程每调用一次方法就会创建一个栈帧，并且把栈帧入栈，一旦方法调用完成，则对应这个方法的栈帧就会出栈。
每个栈帧中都保存着方法的局部变量表、操作数栈、动态连接、方法返回地址

### 本地方法栈
和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。

Native方法是指Java程序中调用非Java语言编写的本地函数，通常是使用C、C++或汇编语言实现的。

### 堆
Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。
此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap） 。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，
所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。

### 方法区
主要包括被虚拟机加载的类信息（字段信息、方法信息、常量、静态变量）和运行时常量池，其中运行时常量池又包括常量和符号引用。

```java
public class BaseConstants {
    /** 常量 */
    public static final int FINAL_CONSTANTS = 1;
    
    /** 类属性（静态变量） */
    public static int DEFAULT_CONSTANTS = 1;
}
```

JDK 1.8 的时候，永久代被彻底移除了，取而代之是元空间(MetaSize)，元空间使用的是直接内存