## IO读写原理

为了避免用户进程直接操作内核，保证内核安全，操作系统将内存（虚拟内存）划分为两部分：
- 内核空间（Kernel-Space） 内核模块运行在内核空间，对应的进程处于内核态；
- 用户空间（User-Space） 用户程序运行在用户空间，对应的进程处于用户态。

用户程序进行IO的读写依赖于底层的IO读写，基本上会用到底层的read和write两大系统调用。

操作系统层面的read系统调用并不是直接从物理设备把数据读取到应用的内存中， write系统调用也不是直接把数据写入物理设备。
上层应用无论是调用操作系统的read还是调用操作系统的write，都会涉及缓冲区：
- 上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区
- 上层应用通过操作系统的write系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区


## IO模型

### BIO 同步阻塞IO

1. 用户线程发起系统调用(read,write)
2. 当系统内核收到系统调用后，进行内核操作,内核操作完成后返回结果 
    - read: 内核缓冲区数据复制至用户缓冲区 
    - write: 用户缓冲区数据复制至内核缓冲区
3. 直到内核返回后用户线程才会解除阻塞的状态

优点:
1. 应用程序开发简单；
2. 在阻塞等待数据期间，用户线程挂起，基本不会占用CPU资源。

缺点:
每个连接配置一个线程，高并发应用场景下需要大量线程，内存、线程切换开销巨大


### NIO 同步非阻塞IO

1. 用户线程发起系统调用(read,write)
2. 系统内核在内核缓冲区数据没准备完成时，立即返回。此时，需要用户线程不停轮询，发起IO调用
3. 内核缓冲区数据到达时，用户线程发起系统调用
   - read: 内核缓冲区数据复制至用户缓冲区
   - write: 用户缓冲区数据复制至内核缓冲区
4. 内核返回结果，用户线程解除阻塞状态

优点:
用户线程系统内核在内核缓冲区数据没准备完成时,可以立即返回，不会阻塞用户线程

缺点:
系统内核在内核缓冲区数据没准备完成时,用户线程不停IO调用，占用大量CPU资源

### IO多路复用

1. 选择器注册，用户线程将需要操作的目标文件描述符(Linux是文件描述符、windows是句柄)注册至select/epoll选择器中
2. 就绪状态的轮询，通过选择器的查询方法，查询所有提前注册过的目标文件描述符的IO就绪状态，并返回就绪的文件描述符列表
3. 用户线程获取就绪的文件描述符列表，进行相应的系统调用(read/write)，用户线程阻塞
4. 系统调用完成后，用户线程继续执行

优点:
一个选择器线程完成多个IO就绪状态的轮询

缺点:
用户线程获取就绪的文件描述符列表，进行相应的系统调用时，这个过程是阻塞得

### 异步IO

1. 用户线程发起系统调用，立即返回结果
2. 系统内核进行相应的系统调用（read/write）,系统调用完成后，回调用户线程注册得回调方法
3. 用户线程读取用户缓冲区数据，完成后续操作

优点:
在内核等待和复制数据的过程中都无需阻塞

缺点:
用户线程仅需要事件得注册和接受，其余都交给了操作系统，因此需要操作系统底层内核提供支持

### Reactor模式

Reactor模式由Reactor线程、Handlers处理器两大角色组成.

1. Reactor线程: 负责响应IO事件并分发到Handler处理器
2. Handlers处理器: 非阻塞的执行业务处理逻辑


#### 单线程模型

1. 作为NIO服务器 接收客户端TCP连接; 读取请求数据并响应
2. 作为NIO客户端 向服务端发起TCP连接; 客户端写请求并读取响应

#### 多线程模型

1. 一个Acceptor线程负责监听客户端连接请求
2. 一组NIO线程处理业务

#### 主从多线程

1. BossGroup 处理连接
2. WorkerGroup 处理业务