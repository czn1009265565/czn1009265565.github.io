## Java 锁

## 背景
锁是为了在多线程环境下保证共享资源安全的一种手段。

在Java中，锁的大分类有乐观锁、悲观锁，其余各种锁是基于这两大分类下的不同实现。

## 乐观锁 VS 悲观锁

- 悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改
- 乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。
  如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）

基于概念可以发现  
- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升

## 公平锁 VS 非公平锁
多线程间如何锁竞争

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。
缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。
但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。
非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

## 自旋锁

阻塞或唤醒一个线程需要操作系统上下文切换，上下文切换是有一定CPU开销的。假如共享资源的锁定时间很短，
那么我们可以当前线程“稍等一下”，也就是进行自旋，那么当前线程就可以不必阻塞而是直接获取共享资源，从而避免切换线程的开销。

## 可重入锁 VS 非可重入锁

首先，我们需要知道可重入锁解决的是什么问题。

可重入锁，也称为递归锁，允许同一个线程在已经持有锁的情况下，可以再次获取该锁而不会造成死锁。
其核心特性是锁能够支持同一线程的多次加锁。

## 互斥锁 VS 共享锁
互斥锁比较容易理解，该锁一次只能被一个线程所持有。
如果线程1对数据A上锁后，则其他线程不能再对A加任何类型的锁。获得互斥锁的线程即能读数据又能修改数据。

共享锁是指该锁可被多个线程所持有。如果线程1对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。
获得共享锁的线程只能读数据，不能修改数据


## synchronized
`synchronized`的使用有三种方式:

1. 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
2. 修饰静态方法: 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
3. 修饰代码块
    - `synchronized(this)` 表示进入同步代码库前要获得当前对象的锁
    - `synchronized(object)` 表示进入同步代码库前要获得给定对象的锁
    - `synchronized(类.class)` 表示进入同步代码前要获得 当前 `class` 的锁

```java
public class SynchronizedTest {
    public synchronized void func1() {
        // 修饰实例方法
    }

    public static synchronized void func2() {
        // 修饰静态方法
    }

    public void func3() {
        synchronized (this) {
            // 获得当前对象的锁
        }
    }

    public void func4(Object object) {
        synchronized (object) {
            // 获得给定对象的锁
        }
    }

    public void func5() {
        synchronized (SynchronizedTest.class) {
            // 当前 class 的锁
        }
    }
}
```

### 底层原理
对象实例在JVM堆中分为三部分

1. 对象头
2. 实例数据
3. 对齐填充字节

在同步的时候,获取对象的monitor即获取对象的锁,无非就是类似对对象的一个标志,
那么这个标志就是存放在Java对象的对象头。Java对象头里的Mark Word里默认的存放的对象的Hashcode,分代年龄和锁标记位

### 锁状态

优化后锁状态分为以下四种,且锁状态只升不降

1. 无锁  
   CAS 无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试
2. 偏向锁  
   偏向锁是指一段同步代码一直被一个线程所访问,那么该线程会自动获取锁而无需通过CAS获取锁,降低获取锁的代价。
3. 轻量级锁
   是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。
4. 重量级锁  
   升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。

### CAS(Compare And Swap)
适用于并发冲突较小的情况

存在的问题:

1. ABA问题

   解决:新增版本号字段
2. 自旋时间过长,导致CPU占用过高
3. 只能保证一个共享变量的原子操作

   当对一个共享变量执行操作时CAS能保证其原子性，如果对多个共享变量进行操作,CAS就不能保证其原子性。
   有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。
   然后将这个对象做CAS操作就可以保证其原子性。atomic中提供了AtomicReference来保证引用对象之间的原子性。

## volatile

1. 只能修饰变量
2. 保证变量在多个线程间的可见性,但不能保证原子性,和有序性

有序性:

引出指令重排,处理器为了提高运行效率,可能会对输入代码进行优化,
不保证执行顺序与代码顺序一致,但会保证最终执行结果和代码顺序执行一致.也就是说如下1,2顺序有可能互换,3和4也有可能互换
指令重排序不会影响单个线程的执行,但是会影响到线程并发执行的正确性.
```
int a = 0; // 1
int b = 0; // 2
a++;       // 3
b++;       // 4
```

应用场景: 状态标志
```
volatile boolean shutdownRequested;  
public void shutdown() {   
    shutdownRequested = true;   
}  
public void doWork() {   
    while (!shutdownRequested) {   
        // 代码业务逻辑  
    }  
}
```
线程A执行doWork()的逻辑代码时，线程B调用了shutdown()方法，线程A立即停止运行while中的逻辑代码。

## Lock
锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源

虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，
可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。

1. `void lock();` 获取锁
2. `void lockInterruptibly() throws InterruptedException;` 获取锁的过程能够响应中断
3. `boolean tryLock();` 非阻塞式响应中断能立即返回，获取锁返回true反之返回fasle
4. `boolean tryLock(long time, TimeUnit unit) throws InterruptedException;` 超时获取锁，在超时内或者未中断的情况下能够获取锁
5. `Condition newCondition();` 获取与lock绑定的等待通知组件，当前线程必须获得了锁才能进行等待，进行等待时会先释放锁，当再次获取锁时才能从等待中返回

### ReentrantLock

```java
public class LockTest {
    // 初始化选择公平锁(true)、非公平锁(false)
    private static ReentrantLock lock = new ReentrantLock(false);

    public void fairLock() {
        // 获取不到锁则阻塞
        lock.lock();
        try {
            // 具体业务逻辑
        } finally {
            lock.unlock();
        }
    }

    public void nonFairLock() {
        boolean condition = lock.tryLock();
        if (!condition){
            // 未获取到锁
            return;
        }
        try {
            // 具体业务逻辑
        }
        finally {
            // 手动释放锁
            lock.unlock();
        }
    }
}
```
