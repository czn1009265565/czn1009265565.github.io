## Java 锁

## 背景
锁是为了在多线程环境下保证共享资源安全的一种手段。

在Java中，锁的大分类有乐观锁、悲观锁，其余各种锁是基于这两大分类下的不同实现。
其中，synchronized关键字和Lock的实现类都是悲观锁，juc下的Atomic类都是基于乐观锁的实现。

## 乐观锁 VS 悲观锁

- 悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改
- 乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。
  如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）

基于概念可以发现  
- 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确
- 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升

## 公平锁 VS 非公平锁
多线程间如何锁竞争

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。
缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。
但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。
非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

## 自旋锁

阻塞或唤醒一个线程需要操作系统上下文切换，上下文切换是有一定CPU开销的。假如共享资源的锁定时间很短，
那么我们可以当前线程“稍等一下”，也就是进行自旋，那么当前线程就可以不必阻塞而是直接获取共享资源，从而避免切换线程的开销。

## 可重入锁 VS 非可重入锁

首先，我们需要知道可重入锁解决的是什么问题。

可重入锁，也称为递归锁，允许同一个线程在已经持有锁的情况下，可以再次获取该锁而不会造成死锁。
其核心特性是锁能够支持同一线程的多次加锁。

## 互斥锁 VS 共享锁
互斥锁比较容易理解，该锁一次只能被一个线程所持有。
如果线程1对数据A上锁后，则其他线程不能再对A加任何类型的锁。获得互斥锁的线程即能读数据又能修改数据。

共享锁是指该锁可被多个线程所持有。如果线程1对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。
获得共享锁的线程只能读数据，不能修改数据


## synchronized
`synchronized`的使用有三种方式:

1. 修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁
2. 修饰静态方法: 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁
3. 修饰代码块
    - `synchronized(this)` 表示进入同步代码库前要获得当前对象的锁
    - `synchronized(object)` 表示进入同步代码库前要获得给定对象的锁
    - `synchronized(类.class)` 表示进入同步代码前要获得 当前 `class` 的锁

```java
public class SynchronizedTest {
    public synchronized void func1() {
        // 修饰实例方法
    }

    public static synchronized void func2() {
        // 修饰静态方法
    }

    public void func3() {
        synchronized (this) {
            // 获得当前对象的锁
        }
    }

    public void func4(Object object) {
        synchronized (object) {
            // 获得给定对象的锁
        }
    }

    public void func5() {
        synchronized (SynchronizedTest.class) {
            // 当前 class 的锁
        }
    }
}
```

### 锁优化

在Java SE 1.6里 `synchronized` 同步锁，一共有四种状态: 无锁、偏向锁、轻量级锁、重量级锁，
它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。

### 偏向锁
背景:  
在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取锁释放锁中，其中并没有锁的竞争。
那么，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。

原理:  
当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁。
只需要简单的测试一下对象头的`Mark Word`里是否存储着指向当前线程的偏向锁。如果成功，表示线程已经获取到了锁。

### 轻量级锁
背景:  
在大多数情况下同步代码块并不会有锁竞争。即使有，也只需要“稍等一下”，没有必要阻塞或唤醒线程，导致徒增切换线程的开销。

原理:  
通过CAS操作来加锁和解锁

### 重量级锁  
背景:  
频繁发生线程竞争

原理:  
重量级锁依赖于操作系统的互斥锁实现，而操作系统中线程间状态的转换需要相对较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。

## Lock

Lock相较synchronized，虽然失去了像synchronize关键字隐式加锁解锁的便捷性，但也获得了更大的扩展性。

- 灵活性: 支持通过`lock()`和`unlock()`方法手动控制锁的获取和释放，支持手动中断和尝试获取锁
- 公平性: 可以通过实现公平锁来确保线程按照请求锁的顺序获得锁

### ReentrantLock

```java
public class LockTest {
    // 初始化选择公平锁(true)、非公平锁(false)
    private static ReentrantLock lock = new ReentrantLock(false);

    public void fairLock() {
        // 获取不到锁则阻塞
        lock.lock();
        try {
            // 具体业务逻辑
        } finally {
            lock.unlock();
        }
    }

    public void nonFairLock() {
        boolean condition = lock.tryLock();
        if (!condition){
            // 未获取到锁
            return;
        }
        try {
            // 具体业务逻辑
        }
        finally {
            // 手动释放锁
            lock.unlock();
        }
    }
}
```

使用选择:  
除非需要使用 `ReentrantLock` 的高级功能，否则优先使用 `synchronized`。
这是因为 `synchronized` 是 `JVM` 实现的一种锁机制，`JVM` 原生地支持它，而 `ReentrantLock` 不是所有的 `JDK` 版本都支持。
并且使用 `synchronized` 不用担心没有释放锁而导致死锁问题，因为 `JVM` 会确保锁的释放。