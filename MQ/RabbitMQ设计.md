# RabbitMQ设计

设计的出发点是为了解决问题，MQ帮我们解决了异步、解耦、削峰的问题，
也会存在消息丢失、消息重复、消息顺序、数据一致性的问题，从问题的角度去看设计，能让我们更好的理解。

## 核心概念

1. 交换机（Exchange）：交换机是消息的分发中心，它接收生产者发送的消息并根据一定的规则将消息路由到一个或多个队列中。RabbitMQ提供了不同类型的交换机，包括：

   - 直连交换机（Direct Exchange）：根据消息的路由键将消息发送到特定队列。
   - 主题交换机（Topic Exchange）：根据消息的路由键和通配符匹配将消息发送到多个队列。
   - 发布/订阅交换机（Fanout Exchange）：将消息广播到与交换机绑定的所有队列。
   - 头部交换机（Headers Exchange）：根据消息的自定义头部属性进行匹配路由。

2. 队列（Queue）：队列是消息的容器，它存储消息直到消费者准备好接收和处理它们。 消息通过交换机路由到队列，消费者可以从队列中读取消息。每个队列都有一个名称，它们可以绑定到一个或多个交换机，并指定了消息的路由规则。

3. 路由键（Routing Key）：路由键是生产者在发布消息时指定的一个关键字，它告诉交换机将消息路由到哪个队列。路由键的意义取决于交换机的类型。在直连交换机中，路由键通常与队列的绑定键一致；在主题交换机中，路由键可以使用通配符进行匹配。

## 模式

1. 单机模式
2. 普通集群
3. 镜像集群（高可用模式）

### 普通集群
**特点:**  
1. 集群中各个节点共享队列元数据（队列名、队列描述、队列所在节点）
2. 集群中各个节点单独存储队列消息

基于上述两个特点，消费者连接到的RabbitMQ节点上没有对应的Queue时，该节点则会根据队列元数据，从对应节点上拉取消息。  
但是如果队列所在节点宕机，那么该队列上的消息就丢失了。

### 镜像集群
镜像集群模式其实就是在普通集群之上把需要的队列做成镜像队列。

#### 镜像队列
- 每个镜像队列都包含一个主节点（master）和若干个从节点（slave）
- 主节点（原始节点）负责处理队列的所有操作
- 如果主节点宕机，从节点可以自动升级为新的主节点，继续提供服务。 

#### 消息消费
- 当消费者与master队列建立连接，消费者可以直接从master队列上拉取信息。
- 当消费者与slave队列建立连接，slave队列先将消费者的请求转发给master队列，master队列准备好数据返回给slave队列，最后由slave队列将消息返回给消费者

#### 负载均衡
消费者的请求都是由master队列进行处理的，那么要实现负载均衡就需要我们将master队列均匀分布在各节点中。

## ACK机制

RabbitMQ 消息确认机制分为两大类：发送方确认、接收方确认

### 发送方确认
生产者发送消息后，需要等待RabbitMQ服务器的确认消息，以确保消息已经被成功地发送到RabbitMQ服务器。  
如果RabbitMQ服务器没有收到消息或者消息发送失败，生产者会收到一个确认消息，从而可以进行重发或者其他处理。

### 接收方确认

消费者接收到消息后，需要向RabbitMQ服务器发送确认消息，以告诉服务器已经成功地接收并处理了该消息。  
如果消费者没有发送确认消息，RabbitMQ服务器会认为该消息没有被正确地处理，从而会将该消息重新发送给其他消费者进行处理。  

**确认示例:**  
```java
@Slf4j
@Component
public class MessageListener {
    @RabbitListener(queues = RabbitMqConfig.TOPIC_QUEUE)
    public void receiveTopic(@Payload Message message, @Headers Map<String,Object> headers, Channel channel) throws IOException {
        log.info("消息接收 message code:{} msg:{}", message.getCode(), message.getMessage());
        /**
         * Delivery Tag 用来标识信道中投递的消息。RabbitMQ 推送消息给 Consumer 时，会附带一个 Delivery Tag，
         * 以便 Consumer 可以在消息确认时告诉 RabbitMQ 到底是哪条消息被确认了。
         * RabbitMQ 保证在每个信道中，每条消息的 Delivery Tag 从 1 开始递增。
         */
        Long deliveryTag = (Long) headers.get(AmqpHeaders.DELIVERY_TAG);
        /**
         *  multiple 取值为 false 时，表示通知 RabbitMQ 当前消息被确认
         *  如果为 true，则额外将比第一个参数指定的 delivery tag 小的消息一并确认
         */
        channel.basicAck(deliveryTag, false);
    }
}
```

## 持久化存储

持久化，即将原本存在于内存中的数据写入到磁盘上永久保存数据，防止服务宕机时内存数据的丢失。  
Rabbitmq 的持久化分为队列持久化、消息持久化和交换器持久化。  
对于消息来说，不管是持久化的消息还是非持久化的消息都可以被写入到磁盘。  
持久化的消息会同时写入磁盘和内存（加快读取速度），非持久化消息会在内存不够用时，将消息写入磁盘。  

### 交换器的持久化
对于消息的可靠性来说，只需要设置队列的持久化和消息的持久化即可。`exchange` 的持久化并没有什么影响。
但是，如果 `exchange` 不设置持久化的话，当 `broker` 服务重启之后，`exchange` 将不复存在，这样会导致消息发送者 producer 无法正常发送消息。


### 队列持久化

- 队列的持久化是在定义队列时的通过 `durable` 参数来决定的，当 `durable` 为 `true` 时，才代表队列会持久化
- 若队列不设置持久化，在rabbitmq服务重启之后，相关队列的元数据和消息数据同时丢失。
- 若队列设置持久化，只能保证队列本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。


### 消息持久化

- 消息持久化的实现需要在发送消息时设置消息的持久化标识
- 当 `broker` 服务其重启后，想要消息不丢失，既需要设置队列持久化，也需要设置消息持久化。
- 但是将所有消息都设置为持久化，会严重影响rabbitmq服务器性能，写入磁盘的速度比写入内存的速度慢得不只一点点。所以对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。
