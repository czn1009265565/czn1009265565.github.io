# RabbitMQ设计

设计的出发点必然是为了解决问题，MQ帮我们解决了异步、解耦、削峰的同时，
也同时带来了消息丢失、消息重复、消息顺序、数据一致性的问题，结合问题去看设计，能让我们知其然也知其所以然。

## 核心概念

1. 交换机（Exchange）：交换机是消息的分发中心，它接收生产者发送的消息并根据一定的规则将消息路由到一个或多个队列中。RabbitMQ提供了不同类型的交换机，包括：

   - 直连交换机（Direct Exchange）：根据消息的路由键将消息发送到特定队列。
   - 主题交换机（Topic Exchange）：根据消息的路由键和通配符匹配将消息发送到多个队列。
   - 发布/订阅交换机（Fanout Exchange）：将消息广播到与交换机绑定的所有队列。
   - 头部交换机（Headers Exchange）：根据消息的自定义头部属性进行匹配路由。

2. 队列（Queue）：队列是消息的容器，它存储消息直到消费者准备好接收和处理它们。 消息通过交换机路由到队列，消费者可以从队列中读取消息。每个队列都有一个名称，它们可以绑定到一个或多个交换机，并指定了消息的路由规则。

3. 路由键（Routing Key）：路由键是生产者在发布消息时指定的一个关键字，它告诉交换机将消息路由到哪个队列。路由键的意义取决于交换机的类型。在直连交换机中，路由键通常与队列的绑定键一致；在主题交换机中，路由键可以使用通配符进行匹配。

## 模式

1. 单机模式
2. 普通集群
3. 镜像集群（高可用模式）

### 普通集群
**特点:**  
1. 集群中各个节点共享队列元数据（队列名、队列描述、队列所在节点）
2. 集群中各个节点单独存储队列消息

基于上述两个特点，消费者连接到的RabbitMQ节点上没有对应的Queue时，该节点则会根据队列元数据，从对应节点上拉取消息。  
但是如果队列所在节点宕机，那么该队列上的消息就丢失了。

### 镜像集群
镜像集群模式其实就是在普通集群之上把需要的队列做成镜像队列。

#### 镜像队列
- 每个镜像队列都包含一个主节点（master）和若干个从节点（slave）
- 主节点（原始节点）负责处理队列的所有操作
- 如果主节点宕机，从节点可以自动升级为新的主节点，继续提供服务。 

#### 消息消费
- 当消费者与master队列建立连接，消费者可以直接从master队列上拉取信息。
- 当消费者与slave队列建立连接，slave队列先将消费者的请求转发给master队列，master队列准备好数据返回给slave队列，最后由slave队列将消息返回给消费者

#### 负载均衡
消费者的请求都是由master队列进行处理的，那么要实现负载均衡就需要我们将master队列均匀分布在各节点中。

## ACK机制

RabbitMQ 消息确认机制分为两大类：发送方确认、接收方确认


## 持久化存储

RabbitMQ的持久化分为三个部分:  
- 交换器的持久化
- 队列的持久化
- 消息的持久化

### 交换器的持久化
- 交换器的持久化是通过在声明交换器时， 指定Durability参数为durable实现的。
- 若交换器不设置持久化，在RabbitMQ服务重启之后，相关的交换器元数据会丢失，但消息不会丢失，只是不能将消息发送到这个交换器中。所以在声明交换器时，都要设置持久化。


### 队列持久化

- 队列的持久化是通过在声明队列时， 指定Durability参数为durable实现的。
- 若队列不设置持久化，在rabbitmq服务重启之后，相关队列的元数据和消息数据同时丢失。
- 若队列设置持久化，只能保证队列本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。


### 消息持久化

- 消息的持久化可以通过消息的投递模式来实现，属于代码层面上的。
- 在web监控页面没有指定持久化的属性参数，但是消息一般都是要设置持久化的，所以在web页面我们可以看到发送消息时下面都带有持久化标识的。
- 但是将所有消息都设置为持久化，会严重影响rabbitmq服务器性能，写入磁盘的速度比写入内存的速度慢得不只一点点。所以对于可靠性不是那么高的消息可以不采用持久化处理以提高整体的吞吐量。在选择是否要将消息持久化时，需要在可靠性和吐吞量之间做一个权衡。
