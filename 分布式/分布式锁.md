# 分布式锁


## Redis实现分布式锁

```shell
# 加锁 set if not exist
setnx key value

# 设置过期时间，避免死锁
expire key sec

# 锁释放
del key
```

### 存在的问题

### 非原子操作
**情况**  
setnx与expire非原子操作

**解决**  
lua脚本执行`setnx + expire`


### 锁误解除
**情况**  
线程A获取锁,执行超时,此时线程B获取锁,线程A释放B的锁

**解决**  
通过在 value 中设置当前线程加锁的标识,在删除之前验证 key 对应的 value 判断锁是否是当前线程持有

### 超时解锁导致并发
**情况**  
线程A获取锁,执行超时,此时线程B获取锁,导致AB并发

**解决**
1. 将过期时间设置足够长,确保代码逻辑在锁释放之前能够执行完成。
2. 为获取锁的线程增加守护线程(watch dog),为将要过期但未释放的锁增加有效时间。

**watch dog 原理:**

1. 在锁未释放时,会不断给锁续期
2. 如何避免锁释放异常,在缓存中缓存ThreadId,移除该ThreadId在锁释放之前,因此续期前检测该ThreadId是否存在即可
3. 如果在分布式服务种该服务挂掉了,watch dog也会挂掉,因此无需担心会一直续期


### 无法等待锁释放
**情况**  
未获取到锁的线程一直轮询,导致cpu占用过高

**解决**  
redis自行实现阻塞队列,原理可以借鉴AQS实现, 锁 + 阻塞队列

### 重复获取锁
**情况**  
Redis集群 `master` 节点获取锁成功还未同步至slave, 但是此时 `master`节点宕机，导致可重复获取锁

**解决**  
红锁

1. 尝试在所有N个Master实例中依次获取锁,所有实例使用相同key,random_value.
   例如锁释放时间为10秒,那么获取锁的超时时间可以设置为5~50毫秒
2. 当且仅当半数以上(N/2+1)实例获得锁,并且获得锁总时间小于锁释放时间,则认为成功获取锁
3. 如果获得锁则认为有效时间为释放时间减去获取锁所消耗的时间
4. 如果获取失败则尝试解锁
