# 分布式事务

分布式事务 是指一个事务操作，需要跨越多个独立的、分布在不同网络节点上的计算资源（例如：多个微服务、多个数据库实例）共同参与完成。
这些参与方必须作为一个整体，全部成功或全部失败，以保证数据的整体一致性。

举个经典例子：用户下单支付

1. 订单服务：创建订单，状态为“待支付”。
2. 库存服务：扣减商品库存。
3. 账户服务：从用户账户扣款。


根据其对一致性的保证程度，大致分为两大类：强一致性方案和最终一致性方案
## 强一致性方案

分布式理论的CP，遵循ACID，对数据要求强一致性。
在业务层的微服务分布式事务设计中，2PC和3PC因其固有的阻塞、单点问题和性能缺陷，已基本被更灵活的最终一致性方案所取代。

### 两阶段提交(2PC)
二阶段提交，顾名思义就是分两个阶段提交  

核心思想：引入一个协调者（Coordinator）来统一管理所有参与者（Participant）的事务提交。
过程分为两个阶段：

1. 准备阶段：协调者询问所有参与者：“是否可以提交？” 参与者执行事务操作，锁定资源，并回复“是”或“否”。
2. 提交/回滚阶段：
   1. 如果所有参与者都回复“是”，协调者向所有参与者发送“提交”指令。
   2. 如果有任何一个参与者回复“否”或超时，协调者则向所有参与者发送“回滚”指令。


**存在的问题:**  
1. 单点故障 (协调者出现故障，整个系统将不可用)
2. 同步阻塞 (所有资源管理器都占用数据库资源，只有当所有节点准备完毕，事务管理器才会通知进行全局提交)
3. 数据不一致 (在第二阶段提交，由于网络问题，只发送了部分提交，使得数据不一致)


### 三阶段提交(3PC)

2PC的改良版，通过增加一个预询阶段和超时机制来减少阻塞和单点问题。

核心思想，分为三个阶段：

1. CanCommit：协调者询问参与者“是否具备提交条件”，不锁定资源，只是一种可行性检查。
2. PreCommit：如果所有参与者回复OK，协调者发送预提交指令，参与者执行事务并锁定资源。
3. DoCommit：协调者发送最终提交指令。

解决的问题:

1. CanCommit 一定程度上解决了资源管理器占用数据库同步阻塞的问题
2. 在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题

## 最终一致性方案
这是互联网分布式系统的主流选择，牺牲强一致性，通过补偿等机制实现数据的最终一致，保证系统的高可用和高性能

### TCC(`try-[confirm/cancel]`)
核心思想：将一个业务逻辑拆分为三个操作，由业务代码实现：

1. Try 阶段：尝试执行。完成所有业务的检查（如库存检查、余额检查），并预留必需的业务资源（如冻结库存、冻结金额）。
2. Confirm 阶段：确认执行。真正执行业务，使用Try阶段预留的资源。该操作需要满足幂等性。
3. Cancel 阶段：取消执行。释放Try阶段预留的资源。该操作也需要满足幂等性。

适用场景：
1. 强隔离性要求的业务，如金融交易、账户扣款。
2. 执行时间较短的业务。
3. 需要高一致性，但又无法使用2PC的场景。

缺点：
1. 侵入性极强，需要改造业务逻辑，为每个服务实现Try/Confirm/Cancel三个接口。
2. 开发复杂度和维护成本高。

### 本地消息表

核心思想：在执行业务操作的同一个数据库事务中，将需要发送的消息作为一条记录插入到业务数据库的一张专门表中。
这样，业务数据和消息数据要么一起提交，要么一起回滚，利用本地数据库的ACID特性解决了最关键的“原子性”问题。
之后，异步任务读取本地消息表进行投递。

优点：

1. 原理简单，通用性强：是解决分布式事务问题的基础性方案，几乎无技术栈限制。
2. 数据强一致的开端：第一阶段利用数据库事务，从根本上避免了业务成功而消息未记录的问题。
3. 高可靠性：通过异步重试机制，能有效应对各种临时性故障（网络抖动、MQ短暂不可用）。

缺点：

1. 业务侵入性：需要业务系统设计消息表，并改造业务代码，在事务中插入消息记录。
2. 性能损耗：消息需要先写数据库，再异步发送，比直接发送MQ多一次数据库写入，有轻微延迟。
3. 运维复杂度：需要额外维护消息发送器集群，并监控消息的积压和失败情况。


### 事务消息(RocketMQ)

1. A 系统先向 mq 发送一条 half 消息，如果 half 消息发送失败，则直接取消操作
2. 如果消息发送成功(Broker ACK)，则执行本地事务
3. 如果本地事务执行成功，则向 mq 发送一条 confirm 消息，如果执行失败，则发送回滚消息
4. 如果RocketMQ没有收到confirm消息，则会发送消息进行事务回查，根据回查结果决定commit或者rollback
5. 系统A事务执行成功并持久化后,系统B执行事务，执行失败则重试

优点：

1. 近乎零侵入：业务方无需创建本地消息表，只需关注本地事务的执行和实现一个检查接口。
2. 数据最终一致：通过两阶段和回查机制，能保证高可靠性。
3. 性能较好：消息无需先落业务数据库，延迟更低。

缺点：

1. 依赖MQ：必须使用支持事务消息的MQ（如RocketMQ）。
2. 有短暂状态不一致：在回查机制下，消息的最终确认会有一定延迟。

对于金融、交易等对一致性要求极高的场景：即使使用MQ事务消息，有时也会结合本地消息表进行二次确认和对账，确保万无一失。


### Saga事务
核心思想是：将一个庞大的分布式长事务 T，拆分成一连串连续的本地子事务（T1, T2, T3, ..., Tn）。
每个本地子事务 Ti 都有对应的补偿操作 Ci（Compensating Action），用于撤销 Ti 造成的影响。

工作原则：

1. 顺序执行：所有子事务按照业务逻辑顺序依次执行。
2. 任何失败则补偿：如果执行到某个子事务 Tk 失败，Saga 会启动补偿流程，按照逆序执行之前所有已成功子事务的补偿操作（Ck, ..., C2, C1）。
3. 补偿操作必须幂等：补偿操作可能会被重试，所以必须保证执行多次的效果和执行一次相同。

Saga 有两种主要的实现和协调方式：协同式（Choreography） 和 编排式（Orchestration）

#### 协同式
这种方式没有中心协调器，每个服务在完成自身操作后，直接发布一个事件（Event）来触发下一个服务的操作。事件通过消息总线（如 RabbitMQ, Kafka）进行传递。

#### 编排式
这种方式引入一个中心化的协调器（Orchestrator）。协调器负责集中管理整个Saga的流程，它向各个参与服务发出命令（Command），并接收服务的回复（Reply），然后决定下一步是执行下一个事务还是启动补偿。

#### 适用场景
1. 业务流程长、步骤多：如电商订单履约（扣库存、扣款、发券、通知物流）、旅行平台订票、保险理赔流程。
2. 遗留系统集成：因为每个步骤都是本地事务，不需要系统提供特殊的锁机制（如XA），更容易集成老系统。
3. 需要高可用性的场景：由于没有全局锁，不会因为一个服务的长时间锁定而导致整个系统卡死。

对于长时间运行的分布式业务事务，Saga 通常是比 TCC 或 2PC 更合适的选择。
在协同式和编排式之间，更推荐使用编排式，因为它通过引入一个中心协调器，极大地简化了分布式系统的复杂度，使业务流程更清晰、更易于维护和扩展。