# Raft算法

## 基本概念
- 目标：在可能发生节点宕机、网络分区等故障的分布式系统中，让多个服务器节点就一系列操作（日志条目）达成强一致

- 基本概念：
  - 状态机复制：Raft 通过复制日志来实现一致性。所有节点从相同的初始状态开始，按相同的顺序执行相同的指令，最终会达到相同的状态
  - 角色（状态）：每个节点在任何时刻都处于以下三种角色之一：
    - Leader（领导者）：集群中唯一的管理者。处理所有客户端请求，负责日志复制
    - Follower（跟随者）：被动地响应来自 Leader 或 Candidate 的请求
    - Candidate（候选者）：在选举新 Leader 时的临时状态
  - 任期（Term）：Raft 将时间划分为任意长度的任期，用连续递增的数字表示。每个任期都以一次选举开始。任期充当逻辑时钟，帮助节点识别过期的信息

## Raft 的三大子问题

Raft 将问题分解为：领导选举（Leader Election）、日志复制（Log Replication） 和 安全性（Safety）

### 领导选举
目标：当集群没有 Leader 或现有 Leader 失效时，快速、安全地选出一个新 Leader。

流程：

1. 初始状态：所有节点启动时都是 Follower。
2. 心跳与超时：
   - Follower 会启动一个随机的选举超时计时器（例如 150ms - 300ms）。
   - 如果在该时间内收到了来自当前 Leader 的有效心跳（AppendEntries RPC），它就重置计时器，保持 Follower 状态。
   - 如果选举超时，Follower 认为 Leader 已失联，开始发起选举。
3. 转为 Candidate 并发起投票：
   - 节点增加自己的当前任期号（currentTerm++）。
   - 转为 Candidate 状态。
   - 先给自己投一票。
   - 向集群中的所有其他节点并行发送 RequestVote RPC。
4. 投票规则：其他节点收到 RequestVote RPC 后，根据以下规则决定是否投票：
   - 规则一：每个节点在一个任期内最多投出一票，遵循“先到先得”原则。
   - 规则二（日志新旧比较）：Candidate 的日志必须至少和自己的一样新。比较方式是：
     - 比较双方最后一条日志的任期号。任期号大的更新。
     - 如果任期号相同，则日志索引大的更新。
   - 只有满足以上两个条件，节点才会投出赞成票。
5. 选举结果：
   - 赢得选举：如果 Candidate 收到了大多数（Majority） 节点的选票，它就赢得选举，成为该任期的 Leader。
   - 其他节点获胜：在等待投票期间，如果收到来自其他节点的 AppendEntries RPC（心跳），且该 RPC 中的任期号 term 大于等于 自己的当前任期，则承认对方是合法 Leader，自身退回 Follower 状态。
   - 选举分裂（Split Vote）：如果多个 Follower 同时超时成为 Candidate，可能导致票数分散，无人获得大多数选票。此时，本次选举超时，所有 Candidate 增加任期号，重置随机选举超时后发起新一轮选举。随机超时机制极大地降低了连续发生选举分裂的概率。

### 日志复制

目标：Leader 接收客户端指令，并将其安全地复制到集群中大多数节点上

日志结构：每个日志条目包含三个要素：

  - 指令（Command）：需要状态机执行的操作。
  - 索引（Index）：日志条目的位置编号。
  - 任期号（Term）：创建该条目时 Leader 的任期号。

流程：

1. 客户端请求：客户端将所有写请求发送给 Leader。
2. 追加本地日志：Leader 将客户端指令作为一条未提交（Uncommitted） 的新日志条目追加到自己的日志中。
3. 并行复制：Leader 通过 AppendEntries RPC 将这条新条目并行地发送给所有 Follower。
4. Follower 响应：Follower 收到 RPC 后，会进行一致性检查：
   - 检查前一条日志的索引和任期号是否与自己本地日志匹配。
   - 如果匹配，则接受新条目，将其追加到本地日志，并返回成功。
   - 如果不匹配（说明有日志冲突），Leader 会回溯日志索引，重试直到找到一致点。
5. Leader 提交：
   - 当 Leader 确认大多数节点都已成功复制该日志条目后，Leader 就提交（Commit） 该条目。
   - 提交意味着该条目被永久持久化，可以安全地应用到状态机。
   - Leader 将指令应用到自己的状态机，并返回结果给客户端。
6. 通知 Follower 提交：在后续的 AppendEntries RPC（心跳或新的日志复制）中，Leader 会携带一个 commitIndex 参数，指示最新已提交的日志索引。Follower 收到后，将本地日志中所有不超过 commitIndex 的已提交条目应用到自己的状态机。

日志匹配特性：
Raft 维护着强大的日志一致性保证，这是通过 AppendEntries RPC 的一致性检查实现的：

- 如果不同日志中的两个条目拥有相同的索引和任期号，那么它们存储了相同的指令。
- 如果不同日志中的两个条目拥有相同的索引和任期号，那么它们之前的所有日志条目也完全相同。

### 安全性

这是 Raft 最关键的保障，确保系统在任何情况下都不会出错。主要有两条规则：

1. 选举限制（Election Restriction）：
  - 如选举流程中所述，只有日志足够新的 Candidate 才能获得投票、成为 Leader。
  - 为什么重要？ 这防止了丢失已提交日志的节点成为 Leader。如果一个节点的日志不是最新的（例如，它宕机期间错过了很多已提交的日志），那么它就不可能获得大多数节点的投票，从而无法成为 Leader。这就保证了新 Leader 一定包含所有已提交的日志条目。
2. 提交之前任期的日志条目：
   - 规则：Leader 在提交一条日志条目时，如果该条目是当前任期创建的，可以直接提交。但如果要提交一条之前任期的日志条目，必须间接地完成。
   - 如何间接提交？ Leader 必须首先将一条当前任期的日志条目复制到大多数节点上。由于日志匹配特性，当这条当前任期的条目被提交时，它之前的所有条目（包括之前任期的条目）也就都被间接提交了。
   - 为什么重要？ 这是对原始 Raft 论文的一个关键修正。它防止了以下极端情况：一个旧 Leader 在日志条目复制到大多数节点但尚未提交时宕机，新 Leader 上台后，由于无法确认该条目是否已提交，可能会用自己的新条目覆盖它。间接提交规则避免了这种已复制但未提交的日志被错误提交或覆盖的风险。