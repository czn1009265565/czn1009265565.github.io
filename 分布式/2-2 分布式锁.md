# 分布式锁
- 线程锁: 主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。
线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，
比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。

- 进程锁: 为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，
因此无法通过synchronized等线程锁实现进程锁。

- 分布式锁: 当多个进程不在同一个系统中(比如分布式系统中控制共享资源访问)，用分布式锁控制多个进程对资源的访问

## Redis分布式锁

### 实现原理
核心命令：`SET key value NX EX timeout`（原子性设置键值并定义过期时间）
续期机制：通过 Redisson 等库的 watchdog 自动延长锁持有时间
集群方案：RedLock 算法（多实例部署，需多数节点获取成功）

### 优点
高性能：基于内存操作，吞吐量高（可达 10万+/秒），适合高并发场景。
简单易用：客户端库丰富（如 Redisson），API 简洁。
可扩展性强：Redis Cluster 支持水平扩展。
自动释放：通过过期时间避免死锁，即使客户端崩溃也能超时释放。

### 缺点
弱一致性：
Redis 异步复制下，主从切换可能导致锁丢失（极端情况）。
RedLock 算法存在争议（Martin Kleppmann 指出时钟漂移可能导致多个客户端同时获锁）。
时钟依赖：依赖系统时间设置过期时间，时钟漂移影响锁准确性。
复杂场景实现成本高：需自行处理锁续期、重入、公平性等（需借助 Redisson 等库）。

### 适用场景
高并发读多写少：如秒杀库存扣减、缓存预热。
对一致性要求不极端：允许短暂锁失效（如业务有重试机制）。


## ZooKeeper 分布式锁

### 实现原理
临时顺序节点：客户端在锁路径下创建临时顺序节点（如 /lock/_c_1）。
监听机制：未获锁的客户端监听前一个节点的删除事件（Watcher）。
公平锁：节点按顺序获锁，天然支持公平性。

### 优点
强一致性：基于 ZAB 协议，数据同步可靠，无脑裂风险。
可靠性高：锁与会话绑定，客户端崩溃时临时节点自动删除，避免死锁。
功能完善：原生支持可重入、公平锁，无需额外逻辑。
无时钟依赖：不依赖系统时间，通过会话机制管理生命周期。

### 缺点
性能较低：写操作需集群多数节点确认，吞吐量低（约万级/秒）。
复杂性高：需维护 ZooKeeper 集群，客户端连接管理复杂（需用 Curator 简化）。
扩展性受限：写性能随节点增加而下降（ZooKeeper 适合少量节点集群）。
网络敏感：会话超时可能导致锁意外释放（需合理配置超时时间）。

### 适用场景
强一致性需求：如金融交易、订单状态同步。
长任务锁：任务执行时间较长，需避免锁超时（如分布式任务调度）。
公平锁需求：如资源按申请顺序分配。
