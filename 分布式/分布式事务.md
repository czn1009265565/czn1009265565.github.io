# 分布式事务

分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。  
简单来说，分布式事务就是为了保证不同数据库的数据一致性。

## 解决方案

### 2PC
二阶段提交，顾名思义就是分两个阶段提交  

**一阶段:**  
1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复。
2. 各参与者执行事务操作，将 `undo` 和 `redo` 信息记入事务日志中（但不提交事务）。
3. 若参与者执行成功，给协调者反馈 yes，否则反馈 no

**二阶段:**  
如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息。


**存在的问题:**  
1. 单点故障 (事务管理器出现故障，整个系统将不可用)
2. 同步阻塞 (所有资源管理器都占用数据库资源，只有当所有节点准备完毕，事务管理器才会通知进行全局提交)
3. 数据不一致 (在第二阶段提交，由于网络问题，只发送了部分提交，使得数据不一致)

### 3PC
- 引入超时机制(包括事务管理器和资源管理器，其中资源管理器超时机制是新引入的)
- 新增CanCommit(准备提交阶段). CanCommit-PreCommit-DoCommit

1. 第一阶段(CanCommit) 事务管理器向所有本地资源管理器发起请求;资源管理器并没有执行事务而是分析事务内容，判断是否可以执行
2. 第二阶段(PreCommit) 事务管理器向所有本地资源管理器发送事务预提交;此时资源管理器执行本地事务,回应Y/N
3. 第三阶段(commit/rollback)

解决的问题:

1. CanCommit 一定程度上解决了资源管理器占用数据库同步阻塞的问题
2. 新增资源管理器超时机制，在第三阶段资源管理器超时未收到commit指令则自动提交，一定程度上解决了数据不一致问题(第三阶段发送abort时网络异常还是会导致数据不一致)

### TCC(`try-[confirm/cancel]`)
TCC 实际上是服务化的两阶段提交协议，业务开发者需要实现这三个服务接口，第一阶段服务由业务代码编排来调用 Try 接口进行资源预留，
所有参与者的 Try 接口都成功了，事务管理器会提交事务，并调用每个参与者的 Confirm 接口真正提交业务操作，否则调用每个参与者的 Cancel 接口回滚事务。

1. 柔性分布式事务,保证最终一致性
2. 解决了资源同步阻塞的问题，因为都是直接进行事务提交，一旦异常则通过回滚补偿机制
3. 对业务的侵入性很强

### 事务消息(RocketMQ)
1. A 系统先向 mq 发送一条 half 消息，如果 half 消息发送失败，则直接取消操作
2. 如果消息发送成功(Broker ACK)，则执行本地事务
3. 如果本地事务执行成功，则向 mq 发送一条 confirm 消息，如果执行失败，则发送回滚消息
4. 如果RocketMQ没有收到confirm消息，则会发送消息进行事务回查，根据回查结果决定commit或者rollback
5. 系统A事务执行成功并持久化后,系统B执行事务，执行失败则重试

应用场景: 跨行转账

