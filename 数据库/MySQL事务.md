## MySQL事务
MySQL事务具有以下四个属性（通常称为ACID属性）
1. 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 并发事务带来的问题
1. 脏读  
   事务T1读取数据并修改，但未提交。此时事务T2读取到了这个未提交的修改值。
2. 不可重复读  
   事务T1多次读取同一数据。于此同时，事务T2也访问该数据，并做了修改提交。
   那么，事务T1两次读数据之间，由于事务T2的修改导致第一个事务两次读取到的数据可能不同。
3. 幻读   
   事务T1读取一组满足某些 <搜索条件> 的数据。事务T2创建了满足T1的 <搜索条件> 的数据项并提交。如果T1用相同的<搜索条件>再次读取，得到一组不同于第一次读取的数据。这就叫幻读

**不可重复读与幻读的区别**
1. 幻读的T1查询是范围查询
2. 幻读定义中 T2 是“创建数据”，不可重复读的定义中 T2 是修改或者删除数据

### 事务隔离级别
1. 读取未提交  
   最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
2. 读取已提交  
   允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
3. 可重复读  
   对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
4. 可串行化  
   最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

`MySQL InnoDB` 默认隔离级别是可重复读RR, 通过 `MVCC` 和 `Next-Key` 解决了幻读的问题。

### InnoDB MVCC 实现原理

InnoDB 中 MVCC 的实现方式为：每一行记录都有两个隐藏列：DATA_TRX_ID、DATA_ROLL_PTR，如果没有主键，则还会多一个隐藏的主键列。

**DATA_TRX_ID**  
记录最近更新这条行记录的事务 ID，大小为 6 个字节

**DATA_ROLL_PTR**  
表示指向该行回滚段（rollback segment）的指针，大小为 7 个字节，
InnoDB 便是通过这个指针找到之前版本的数据。该行记录上所有旧版本，在 undo 中都通过链表的形式组织。

**DB_ROW_ID**  
行标识（隐藏单调自增 ID），大小为 6 字节，如果表没有主键，InnoDB 会自动生成一个隐藏主键，
因此会出现这个列。另外，每条记录的头信息（record header）里都有一个专门的 bit（deleted_flag）来表示当前记录是否已经被删除。

**Read View**  
ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。
ReadView中包含了四个核心字段：

- `m_low_limit_id`：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见
- `m_up_limit_id`：活跃事务列表 `m_ids` 中最小的事务 ID，如果 `m_ids` 为空，则 `m_up_limit_id` 为 `m_low_limit_id`。小于这个 ID 的数据版本均可见
- `m_ids`：`Read View` 创建时其他未提交的活跃事务 ID 列表。创建 `Read View`时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。`m_ids` 不包括当前事务自己和已提交的事务（正在内存中）
- `m_creator_trx_id`：创建该 `Read View` 的事务 ID
