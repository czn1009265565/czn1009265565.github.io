# MySQL事务
MySQL事务具有以下四个属性（通常称为ACID属性）  
1. 原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. 隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

## 并发事务带来的问题
1. 脏读  
   事务T1读取数据并修改，但未提交。此时事务T2读取到了这个未提交的修改值。
2. 不可重复读  
   事务T1多次读取同一数据。于此同时，事务T2也访问该数据，并做了修改提交。
   那么，事务T1两次读数据之间，由于事务T2的修改导致第一个事务两次读取到的数据可能不同。
3. 幻读   
   事务T1读取一组满足某些 <搜索条件> 的数据。事务T2创建了满足T1的 <搜索条件> 的数据项并提交。如果T1用相同的<搜索条件>再次读取，得到一组不同于第一次读取的数据。这就叫幻读

**不可重复读与幻读的区别**
1. 幻读的T1查询是范围查询
2. 幻读定义中 T2 是“创建数据”，不可重复读的定义中 T2 是修改或者删除数据

## MVCC
MVCC 全称 Mutil-Version Concurrency Control，多版本并发控制，在不加锁的情况下，解决了并发 `读+写` 冲突问题。
而对于 `写+写` 事务并发则只能通过加锁解决。

### 当前读+快照读

- 当前读：当前读会对读取的记录加锁，保证读取数据是最新版本

- 快照读: 读取的是历史快照数据

## MVCC 实现原理

### 隐藏字段

在内部，`InnoDB` 存储引擎为每行数据添加了三个隐藏字段

- row_id: 当表没定义主键时，InnoDB 会以 row_id 为主键生成一个聚集索引
- trx_id: 记录了新增/最近修改这条记录的事务 id，事务 id 是自增的
- roll_pointer: 回滚指针指向当前记录的上一个版本(在undo log 中)

![undo log](./imgs/undo%20log.png)

### ReadView
ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，ReadView中包含了四个核心字段:

- creator_trx_id: 当前事务 id
- m_ids: 活跃事务 id 列表，当前系统中所有活跃的（也就是没提交的）事务的事务 id 列表
- min_trx_id: m_ids 中最小的事务 id
- max_trx_id: 生成 ReadView 时，系统应该分配给下一个事务的 id，注意不是 m_ids 中最大的事务 id，也就是 m_ids 中的最大事务 id + 1

**查询规则**  
1. 当【版本链中记录的 trx_id 等于当前事务 id（trx_id = creator_trx_id）】时，说明版本链中的这个版本是当前事务修改的，所以该快照记录对当前事务可见
2. 当【版本链中记录的 trx_id 小于活跃事务的最小 id（trx_id < min_trx_id）】时，说明版本链中的这条记录已经提交了，所以该快照记录对当前事务可见
3. 当【版本链中记录的 trx_id 大于下一个要分配的事务 id（trx_id > max_trx_id）】时，该快照记录对当前事务不可见
4. 当【版本链中记录的 trx_id 大于等于最小活跃事务 id】且【版本链中记录的 trx_id 小于下一个要分配的事务 id】（min_trx_id <= trx_id < max_trx_id）时，如果版本链中记录的 trx_id 在活跃事务id列表 m_ids 中，说明生成 ReadView 时，修改记录的事务还没提交，所以该快照记录对当前事务不可见，否则该快照记录对当前事务可见

