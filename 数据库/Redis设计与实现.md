# Redis设计与实现

## 应用场景

1. 缓存: 热点数据例如排行榜
2. 分布式数据共享: 分布式Session
3. 分布式锁
4. 消息队列(一般不用)
5. 计数器: 阅读量、点赞数,先写入Redis再定时同步到数据库
6. 限流


## 数据结构和对象

1. 简单动态字符串(SDS)
   
```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量，即SDS所保存字符串的长度
    unsigned int len;
    // 记录buf数据中未使用的字节数量
    unsigned int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```
SDS相较C的String优点:

 - 获取字符串长度O(1)
 - 存储文本信息和二进制数据

C的String为什么不能存储二进制数据,因为C的字符串是由长度为N+1字符数组来表示的,
并且字符串以'\0'结尾,不允许'\0'出现在字符串中间.而SDS以len来判断字符串长度

2. 链表(双向无环链表)

```c
struct listNode {
     // 前置节点
     struct listNode *prev;
     // 后置节点
     struct listNode *next;
     // 节点值
     void *value;
}
```
3. 字典
   
与HashMap类似 数组 + 链表
```c
struct dictht {
     // 哈希表数组
     dictEntry **table;
     
     // 哈希表大小
     unsigned long size;

     // 哈希表大小掩码
     unsigned long sizemask;

     // 已有节点数量
     unsigned long used; 
}

struct dictEntry {
    void *key;
    
    union {
      void *val;
    } 
    
    struct dictEntry *next;
}
```
4. 跳跃表 (zset)

```c
struct skiplist {
   // 表头节点和表尾节点
   skipNode *header,*tail;
   // 表中节点数量
   unsigned long length;
   // 表中层数最大的节点层数
   int level;
}

struct skiplistNode {
   skiplistLevel {
      // 前进指针
      struct skiplistNode *forward;
      // 跨度
      unsigned int span;
   } level[];
   // 后退指针
   struct skiplistNode *backward;
   // 分值
   double score;
   // 成员对象
   robj *robj;
}
```
   
   1. 查找
      ```
      1       5
      1   3   5   7
      1 2 3 4 5 6 7 8
      ```
      查找顺序`1->5->3->4`
   2. 插入
      
      先查找,后插入,问题来了,插入后如何重建索引,让其近似均匀
      
      - 随机生成1~MAX_LEVEL 随机数
      - 1概率1/2,2概率1/4,3概率1/8...
      - 1不建索引,2建一级索引,3建二级索引...
      
   3. 删除
      
      删除元素的同时删除索引
      
## 单机数据库实现

### 过期删除策略
1. 惰性删除 : 只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. 定期删除 : 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。

### 内存淘汰机制
6种内存淘汰策略,最常用的如下两种

1. 从设置过期时间的数据集中，挑选最少使用的数据淘汰
2. 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key

### 持久化机制
1. RDB
   1. Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本
   2. 保存更耗时，耗性能
   3. 灾难恢复时更快

   ```
   save 900 10 # 300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照
   ```
2. AOF
   开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。

   1. 具有每秒同步和每次同步选项
   2. 相同数据量下，文件大小AOF文件通常比RDB更大
   3. 在大量写入和载入的时候，AOF的效率会比RDB低

   ```
   appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
   appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
   appendfsync no        #让操作系统决定何时进行同步
   ```
   AOF重写

### 事件处理
1. 多个 socket（客户端连接）
2. IO 多路复用程序（支持多个客户端连接的关键）
3. 文件事件分派器（将 socket 关联到相应的事件处理器）
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）


Reactor线程模型(Redis 采用Reactor单线程)

1. Reactor单线程
2. Reactor多线程
3. Reactor主从多线程

单线程的优势:

1. Redis 的性能瓶颈不在 CPU ，主要在内存和网络
2. 避免上下文切换,锁的性能开销
3. 单线程编码简单更易维护

Redis6.0引入多线程,仅在网络数据读写上使用.

## 多机数据库

### 主从复制
1. 旧版复制
   
   - 同步: 将从服务器的数据库状态更新至主服务器当前所处状态
      
      1. 从服务器发送SYNC
      2. 主服务器执行BGSAVE,生成RDB并使用缓冲区记录现在开始执行的写命令
      3. 主服务器发送RDB
      4. 从服务器更新完毕后,主服务器发送缓冲区的写命令

   - 命令传播: 主服务器将写命令发送给从服务器
   
   存在的问题: 断线复制效率低
   
2. 新版复制
   
   就是为了解决部分断线复制问题

   1. 主从服务器记录偏移量
   2. 主服务器缓存最近传播的写命令
   
   缓存默认1M,如果说断线时间过长则没办法生效,因此也需要设置一个合理的缓存大小

没办法对Master进行动态选举

### 哨兵模式

作用:

1. 通过发送命令监控主从服务器运行状态
2. 当哨兵监控到master宕机,会自动将slave切换成master,然后通过发布订阅通知其他从服务器

故障切换过程:

1. 每个哨兵进程以每秒一次的频率向主从服务器发送一次ping
2. 如果一个实例最后回复有效时间超过设定的值,则哨兵将其标记为主观下线
3. 如果master被标记为主观下线,则监控该master的所有哨兵以每秒一次的请求频率再次去确认是否确实主观下线
4. 当足够多的哨兵确认master主观下线,则将该master标记为客观下线;若没有足够多的哨兵确认则移除主观下线
5. 当master被标记为客观下线时,选举领头哨兵,负责挑选从服务器转化为主服务器,设置其余从服务器复制新主服务器(slaveof),设置下线主服务器复制新主服务器

### 集群
当数据量过大到一台服务器存放不下的情况时,主从模式或sentinel模式就不能满足需求了,这个时候需要对存储的数据进行分片,将数据存储到多个Redis实例中

## 常见问题及解决
### 缓存穿透
大量请求的 key 根本不存在于缓存中,导致请求直接请求到数据库

举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决方案:
1. 缓存无效key

   容易缓存大量无效key,不能从根本上解决问题.
2. 布隆过滤器

   把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

   实现原理参考hashMap 存在不一定存在(因为可能计算出相同的位移)不存在则一定不存在

### 缓存雪崩
大批量热点缓存同时失效

1. 设置不同的失效时间
2. 永不失效

### 缓存击穿
大并发集中访问单个热点key,当该key失效时,大量请求直接请求数据库

设置热点数据永不过期

### Redis实现分布式锁
1. setnx key value // 加锁
2. expire key sec  // 锁过期时间,避免死锁
3. del key         // 锁释放

存在的问题:

1. setnx expire 非原子操作
   ```
   // lua脚本执行setnx + expire
   // 注意点:有点类似multi exec redis事务,中间指令操作失败不会使前面的指令回滚,也不会使后面的指令跳过
   EVAL "if (redis.call('setnx',KEYS[1],ARGV[1]) < 1) then return 0; end; redis.call('expire',KEYS[1],tonumber(ARGV[2])); return 1;" 1 key value 100
   ```
   说白了想要保证原子性,就需要确保同一时间仅有一个线程操作,在Java种，我们可以通过加锁来保证.
   官方解释:Redis使用相同的lua解释器来运行命令,在执行脚本时,不会执行其他脚本或Redis命令
   个人理解:Redis事件处理基于Reactor单线程模型
   
2. 锁误解除.线程A获取锁,执行超时,此时线程B获取锁,线程A释放B的锁

   通过在 value 中设置当前线程加锁的标识,在删除之前验证 key 对应的 value 判断锁是否是当前线程持有.可生成一个 UUID 标识当前线程(机器Id + 线程Id)
3. 超时解锁导致并发.线程A获取锁,执行超时,此时线程B获取锁,导致AB并发

   1. 将过期时间设置足够长,确保代码逻辑在锁释放之前能够执行完成。
   2. 为获取锁的线程增加守护线程(watch dog),为将要过期但未释放的锁增加有效时间。
   
   watch dog 原理: 
   
   1. 在锁未释放时,会不断给锁续期
   2. 如何避免锁释放异常,在缓存中缓存ThreadId,移除该ThreadId在锁释放之前,因此续期前检测该ThreadId是否存在即可
   3. 如果在分布式服务种该服务挂掉了,watch dog也会挂掉,因此无需担心会续期
4. 无法等待锁释放
   
   1. 轮询,cpu占用过高
   2. 发布订阅
   3. redis自行实现阻塞队列,原理可以借鉴AQS实现, 锁 + 阻塞队列
5. master 获取锁成功还未同步至slave,master 宕机,导致可重复获取锁
   
   解决办法:红锁

   1. 尝试在所有N个Master实例中依次获取锁,所有实例使用相同key,random_value.
      例如锁释放时间为10秒,那么获取锁的超时时间可以设置为5~50毫秒
   2. 当且仅当半数以上(N/2+1)实例获得锁,并且获得锁总时间小于锁释放时间,则认为成功获取锁
   3. 如果获得锁则认为有效时间为释放时间减去获取锁所消耗的时间
   4. 如果获取失败则尝试解锁
   

