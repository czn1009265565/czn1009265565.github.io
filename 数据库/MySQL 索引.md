## MySQL索引

### 优缺点
**优点:**
1. 加快检索速度
2. 唯一索引确保数据唯一性

**缺点:**  
1. 索引存储占用空间
2. 数据增删改查,如果数据有索引，索引也需动态修改


### 数据结构

#### Hash表
哈希表是键值对的集合，底层实现是基于数组和链表。

#### 二叉树
二叉树是一种每个节点最多有两个子节点的树结构

#### 二叉查找树
二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：

1. 左子树所有节点的值均小于根节点的值。
2. 右子树所有节点的值均大于根节点的值。
3. 左右子树也分别为二叉查找树。

**二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。**

#### 红黑树
红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：

1. 每个节点非红即黑。
2. 根节点总是黑色的。
3. 每个叶子节点都是黑色的空节点（NIL 节点）。
4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）。
5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

红黑树具有良好的平衡性，查询效率较高，且适用于内存中的数据结构。但是红黑树与二叉树类似，每个节点只存储一个关键字和数据，
所以，如果想要存储更多的数据量，则需要更多节点，更大的高度，此时不但会增加内存开销，随着数据量的增加，I/O次数也会相应增加。
同时，红黑树中的平衡调整会涉及到节点的旋转操作，这些操作需要在磁盘中进行，因此红黑树的平衡调整会涉及到更多的磁盘I/O操作，会影响索引查询的效率。

#### B 树& B+树
B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

**B 树& B+树两者有何异同呢？**

- B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

### 聚簇索引和非聚簇索引
1. 聚簇索引  
   叶子节点存储的data是该行数据，主键索引就是典型的聚簇索引
2. 非聚簇索引  
   叶子节点存储的data是主键ID，因此还需要一次回表查询

这里又可以引出覆盖索引，也就是说所有的非聚簇索引都需要回表查询吗？  
不一定，因为可以创建指定的查询所需字段的组合索引

### 最左前缀匹配原则
所谓最左原则指的就是如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配，
值得注意的是，当遇到范围查询(>、<、between、like)就会停止匹配。

因此当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。
如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。

实战题型(重点)

1. 题型一

   如果sql为
   `SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;`
   如何建立索引?
   如果此题回答为对(a,b,c)建立索引，那都可以回去等通知了。
   此题正确答法是，(a,b,c)或者(c,b,a)或者(b,a,c)都可以，重点要的是将区分度高的字段放在前面，区分度低的字段放后面。像性别、状态这种字段区分度就很低，我们一般放后面。

   例如假设区分度由大到小为b,a,c。那么我们就对(b,a,c)建立索引。在执行sql的时候，优化器会 帮我们调整where后a,b,c的顺序，让我们用上索引。

2. 题型二

   如果sql为
   `SELECT * FROM table WHERE a > 1 and b = 2;`
   如何建立索引?
   如果此题回答为对(a,b)建立索引，那都可以回去等通知了。
   此题正确答法是，对(b,a)建立索引。如果你建立的是(a,b)索引，那么只有a字段能用得上索引，毕竟最左匹配原则遇到范围查询就停止匹配。
   如果对(b,a)建立索引那么两个字段都能用上，优化器会帮我们调整where后a,b的顺序，让我们用上索引。

3. 题型三

   如果sql为
   `SELECT * FROM table WHERE a > 1 and b = 2 and c > 3;`
   如何建立索引?
   此题回答也是不一定，(b,a)或者(b,c)都可以，要结合具体情况具体分析。

   拓展一下

   `SELECT * FROM table WHERE a = 1 and b = 2 and c > 3;`
   怎么建索引？嗯，大家一定都懂了！

4. 题型四

   `SELECT * FROM table WHERE a = 1 ORDER BY b;`
   如何建立索引？
   这还需要想？一看就是对(a,b)建索引，当a = 1的时候，b相对有序，可以避免再次排序！
   那么

   `SELECT * FROM table WHERE a > 1 ORDER BY b;`
   如何建立索引？
   对(a)建立索引，因为a的值是一个范围，这个范围内b值是无序的，没有必要对(a,b)建立索引。

   拓展一下

   `SELECT * FROM table WHERE a = 1 AND b = 2 AND c > 3 ORDER BY c;`
   怎么建索引?

5. 题型五

   `SELECT * FROM table WHERE a IN (1,2,3) and b > 1;`
   如何建立索引？
   还是对(a，b)建立索引，因为IN在这里可以视为等值引用，不会中止索引匹配，所以还是(a,b)!

   拓展一下

   `SELECT * FROM table WHERE a = 1 AND b IN (1,2,3) AND c > 3 ORDER BY c;`
   如何建立索引？此时c排序是用不到索引的。

### 前缀索引
使用前缀索引，定义好合适的长度(参考指定长度的区分度)，就可以做到既节省空间，又不用额外增加太多的查询成本。  
使用前缀索引有可能会用不上覆盖索引对于查询的优化。
