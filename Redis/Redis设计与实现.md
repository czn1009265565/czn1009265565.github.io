# Redis设计与实现

## 应用场景

1. 缓存: Redis 可以作为应用程序的缓存层，减少数据库的读取压力，提高数据访问速度
2. 会话存储: 在 Web 应用中，Redis 可以用来存储用户的会话信息
3. 分布式锁: 在分布式系统中，Redis 可以用于实现分布式锁，确保在多个节点之间共享资源的一致性
4. 消息队列(一般不用)
5. 计数器: 阅读量、点赞数、库存数等，基于Lua脚本实现原子操作
6. 限流

## 数据类型
1. 字符串(String)
2. 列表(List)
3. 集合(Set)
4. 有序集合(ZSet)
5. 字典(Hash)

### 字符串(String)

简单动态字符串(SDS)
   
```c
struct sdshdr {
    // 记录buf数组中已使用字节的数量，即SDS所保存字符串的长度
    unsigned int len;
    // 记录buf数据中未使用的字节数量
    unsigned int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```
SDS相较C的String优点:

 - 获取字符串长度O(1)
 - 存储文本信息和二进制数据

C的String为什么不能存储二进制数据,因为C的字符串是由长度为N+1字符数组来表示的,
并且字符串以'\0'结尾,不允许'\0'出现在字符串中间.而SDS以len来判断字符串长度

### 列表(List)
双向链表

```c
struct listNode {
     // 前置节点
     struct listNode *prev;
     // 后置节点
     struct listNode *next;
     // 节点值
     void *value;
}
```

### 字典(Hash)
与HashMap类似 数组 + 链表

```c
struct dictht {
     // 哈希表数组
     dictEntry **table;
     
     // 哈希表大小
     unsigned long size;

     // 哈希表大小掩码
     unsigned long sizemask;

     // 已有节点数量
     unsigned long used; 
}

struct dictEntry {
    void *key;
    
    union {
      void *val;
    } 
    
    struct dictEntry *next;
}
```

### 集合(Set)

与HashSet类似

### 有序集合(ZSet)
Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，
使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。

底层实现: 跳表

```
1       5
1   3   5   7
1 2 3 4 5 6 7 8
```
- 跳表由多层组成，每一层都是一个有序链表。最底层包含所有元素，每一层的元素数量逐层减少
- 通过在每一层中跳过部分元素，平均时间复杂度为 O(log n)，使得查找效率接近于二分查找
- 相对于红黑树来说，实现更简单，占用更少的内存，简单的删除和插入不需要进行复杂的平衡操作

## 持久化机制

一般来说同时使用两种持久化方式

### RDB

RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。

特点:  
1. 数据的完整性和一致性不高，系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失
2. 备份更耗时，耗性能，因为每次备份都是基于快照的全量备份
3. 灾难恢复时更快

### AOF
AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。

特点:  
1. 数据的完整性和一致性更高，支持每秒同步或每次同步
2. 占用磁盘空间大，数据恢复速度慢
3. 运行效率会比RDB低

## 过期删除策略

1. **惰性删除**：只会在取出/查询 key 的时候才对数据进行过期检查。这种方式对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。
2. **定期删除**：周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期，过期就删除 key。相比于惰性删除，定期删除对内存更友好，对 CPU 不太友好。
3. **延迟队列**：把设置过期时间的 key 放到一个延迟队列里，到期之后就删除 key。这种方式可以保证每个过期 key 都能被删除，但维护延迟队列太麻烦，队列本身也要占用资源。
4. **定时删除**：每个设置了过期时间的 key 都会在设置的时间到达时立即被删除。这种方法可以确保内存中不会有过期的键，但是它对 CPU 的压力最大，因为它需要为每个键都设置一个定时器。

Redis 采用的是 **定期删除+惰性删除** 结合的策略。

## 内存淘汰策略

- LRU：最近最少使用淘汰算法（Least Recently Used）。LRU是淘汰最长时间没有被使用的数据
- LFU：最不经常使用淘汰算法（Least Frequently Used）。LFU是淘汰一段时间内，使用次数最少的数据
- volatile：表示从设置了过期时间的键值中淘汰数据
- allkeys：表示从所有的键值中淘汰数据

1. **no-eviction**（默认内存淘汰策略）：当内存不足以容纳新写入数据时，新写入操作会报错。
2. **volatile-lru（least recently used）**：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。
3. **volatile-lfu（least frequently used）**：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰。
4. **volatile-ttl**：从已设置过期时间的数据集中挑选将要过期的数据淘汰。
5. **volatile-random**：从已设置过期时间的数据集中任意选择数据淘汰。
6. **allkeys-lru（least recently used）**：从数据集中移除最近最少使用的数据淘汰。
7. **allkeys-lfu（least frequently used）**：从数据集中移除最不经常使用的数据淘汰。
8. **allkeys-random**：从数据集中任意选择数据淘汰。


## 事件处理
1. 多个 socket（客户端连接）
2. IO 多路复用程序（支持多个客户端连接的关键）
3. 文件事件分派器（将 socket 关联到相应的事件处理器）
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）


Reactor线程模型(Redis 采用Reactor单线程)

1. Reactor单线程
2. Reactor多线程
3. Reactor主从多线程

单线程的优势:

1. Redis 的性能瓶颈不在 CPU ，主要在内存和网络
2. 避免上下文切换,锁的性能开销
3. 单线程编码简单更易维护

Redis6.0引入多线程,仅在网络数据读写上使用.

## Redis集群

### 主从复制
1. 旧版复制
   
   - 同步: 将从服务器的数据库状态更新至主服务器当前所处状态
      
      1. 从服务器发送SYNC
      2. 主服务器执行BGSAVE,生成RDB并使用缓冲区记录现在开始执行的写命令
      3. 主服务器发送RDB
      4. 从服务器更新完毕后,主服务器发送缓冲区的写命令

   - 命令传播: 主服务器将写命令发送给从服务器
   
   存在的问题: 断线复制效率低
   
2. 新版复制
   
   就是为了解决部分断线复制问题

   1. 主从服务器记录偏移量
   2. 主服务器缓存最近传播的写命令
   
   缓存默认1M,如果说断线时间过长则没办法生效,因此也需要设置一个合理的缓存大小

没办法对Master进行动态选举

### 哨兵模式
Redis 哨兵模式是指在 Redis **主从集群**(读写分离)，有一组专门的哨兵进程负责监控主从节点状态，并在发现故障时自动进行故障转移，以保证 Redis 集群的高可用性。

故障切换过程:

1. 每个哨兵进程以每秒一次的频率向主从服务器发送一次ping
2. 如果一个实例最后回复有效时间超过设定的值,则哨兵将其标记为主观下线
3. 如果master被标记为主观下线,则监控该master的所有哨兵以每秒一次的请求频率再次去确认是否确实主观下线
4. 当足够多的哨兵确认master主观下线,则将该master标记为客观下线;若没有足够多的哨兵确认则移除主观下线
5. 当master被标记为客观下线时,选举领头哨兵,负责挑选从服务器转化为主服务器,设置其余从服务器复制新主服务器(slaveof),设置下线主服务器复制新主服务器

### 集群
当数据量过大到一台服务器存放不下的情况时,主从模式或sentinel模式就不能满足需求了,这个时候需要对存储的数据进行分片,将数据存储到多个Redis实例中

## 常见问题及解决
### 缓存穿透
大量请求的 key 根本不存在于缓存中,导致请求直接请求到数据库

举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

解决方案:
1. 缓存无效key

   容易缓存大量无效key,不能从根本上解决问题.
2. 布隆过滤器

   把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

   实现原理参考hashMap 存在不一定存在(因为可能计算出相同的位移)不存在则一定不存在

### 缓存雪崩
大批量热点缓存同时失效

1. 设置不同的失效时间
2. 永不失效

### 缓存击穿
大并发集中访问单个热点key,当该key失效时,大量请求直接请求数据库

设置热点数据永不过期

### Redis实现分布式锁
1. setnx key value // 加锁
2. expire key sec  // 锁过期时间,避免死锁
3. del key         // 锁释放

存在的问题:

1. setnx expire 非原子操作
   ```
   // lua脚本执行setnx + expire
   // 注意点:有点类似multi exec redis事务,中间指令操作失败不会使前面的指令回滚,也不会使后面的指令跳过
   EVAL "if (redis.call('setnx',KEYS[1],ARGV[1]) < 1) then return 0; end; redis.call('expire',KEYS[1],tonumber(ARGV[2])); return 1;" 1 key value 100
   ```
   说白了想要保证原子性,就需要确保同一时间仅有一个线程操作,在Java种，我们可以通过加锁来保证.
   官方解释:Redis使用相同的lua解释器来运行命令,在执行脚本时,不会执行其他脚本或Redis命令
   个人理解:Redis事件处理基于Reactor单线程模型
   
2. 锁误解除.线程A获取锁,执行超时,此时线程B获取锁,线程A释放B的锁

   通过在 value 中设置当前线程加锁的标识,在删除之前验证 key 对应的 value 判断锁是否是当前线程持有.可生成一个 UUID 标识当前线程(机器Id + 线程Id)
3. 超时解锁导致并发.线程A获取锁,执行超时,此时线程B获取锁,导致AB并发

   1. 将过期时间设置足够长,确保代码逻辑在锁释放之前能够执行完成。
   2. 为获取锁的线程增加守护线程(watch dog),为将要过期但未释放的锁增加有效时间。
   
   watch dog 原理: 
   
   1. 在锁未释放时,会不断给锁续期
   2. 如何避免锁释放异常,在缓存中缓存ThreadId,移除该ThreadId在锁释放之前,因此续期前检测该ThreadId是否存在即可
   3. 如果在分布式服务种该服务挂掉了,watch dog也会挂掉,因此无需担心会续期
4. 无法等待锁释放
   
   1. 轮询,cpu占用过高
   2. 发布订阅
   3. redis自行实现阻塞队列,原理可以借鉴AQS实现, 锁 + 阻塞队列
5. master 获取锁成功还未同步至slave,master 宕机,导致可重复获取锁
   
   解决办法:红锁

   1. 尝试在所有N个Master实例中依次获取锁,所有实例使用相同key,random_value.
      例如锁释放时间为10秒,那么获取锁的超时时间可以设置为5~50毫秒
   2. 当且仅当半数以上(N/2+1)实例获得锁,并且获得锁总时间小于锁释放时间,则认为成功获取锁
   3. 如果获得锁则认为有效时间为释放时间减去获取锁所消耗的时间
   4. 如果获取失败则尝试解锁
   

